<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Robust AR Surface</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: monospace; }
        
        /* 1. VIDEO FEED (Background) */
        #camera-feed {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            min-width: 100%; min-height: 100%;
            width: auto; height: auto;
            z-index: 0;
            object-fit: cover;
        }

        /* 2. AR CANVAS (Overlay) */
        #ar-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
            background: transparent;
        }

        /* 3. UI & DEBUG */
        #ui-layer {
            position: absolute;
            bottom: 20px; left: 0; width: 100%;
            z-index: 10;
            text-align: center;
            pointer-events: none;
        }

        #btn-start {
            pointer-events: auto;
            background: #007AFF;
            color: white;
            padding: 15px 40px;
            font-size: 18px;
            border: none;
            border-radius: 50px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        #debug {
            position: absolute;
            top: 10px; left: 10px;
            color: #00FF00;
            background: rgba(0,0,0,0.6);
            padding: 5px;
            font-size: 10px;
            z-index: 20;
            pointer-events: none;
            white-space: pre-wrap;
        }
    </style>
    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <video id="camera-feed" playsinline autoplay muted></video>
    <canvas id="ar-overlay"></canvas>
    <div id="debug">System Ready.</div>
    
    <div id="ui-layer">
        <button id="btn-start">INITIALIZE SENSORS</button>
        <p style="color:white; font-size:12px; text-shadow:1px 1px 2px black;">Tap screen to place marker</p>
    </div>

    <script>
        /**
         * --------------------------------------------------------------------------
         * INLINED LIBRARY: DeviceOrientationControls
         * This algorithm handles the complex Math (Quaternions) to keep the object
         * stable even on old devices.
         * --------------------------------------------------------------------------
         */
        class DeviceOrientationControls {
            constructor(object) {
                this.object = object;
                this.object.rotation.reorder('YXZ');
                this.enabled = true;
                this.deviceOrientation = {};
                this.screenOrientation = 0;
                this.alphaOffset = 0; // Initial offset to face forward
                
                this.onDeviceOrientationChangeEvent = (event) => { this.deviceOrientation = event; };
                this.onScreenOrientationChangeEvent = () => { this.screenOrientation = window.orientation || 0; };

                window.addEventListener('deviceorientation', this.onDeviceOrientationChangeEvent, false);
                window.addEventListener('orientationchange', this.onScreenOrientationChangeEvent, false);
                this.onScreenOrientationChangeEvent(); // Init
            }

            update() {
                if (!this.enabled || !this.deviceOrientation.alpha) return;

                const alpha = this.deviceOrientation.alpha ? THREE.Math.degToRad(this.deviceOrientation.alpha) + this.alphaOffset : 0;
                const beta = this.deviceOrientation.beta ? THREE.Math.degToRad(this.deviceOrientation.beta) : 0;
                const gamma = this.deviceOrientation.gamma ? THREE.Math.degToRad(this.deviceOrientation.gamma) : 0;
                const orient = this.screenOrientation ? THREE.Math.degToRad(this.screenOrientation) : 0;

                this.setObjectQuaternion(this.object.quaternion, alpha, beta, gamma, orient);
            }

            setObjectQuaternion(quaternion, alpha, beta, gamma, orient) {
                // The "Magic" Mathematics to fuse sensors correctly
                const zee = new THREE.Vector3(0, 0, 1);
                const euler = new THREE.Euler();
                const q0 = new THREE.Quaternion();
                const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 around the x-axis

                euler.set(beta, alpha, -gamma, 'YXZ'); // 'ZXY' for the device, but 'YXZ' for us
                quaternion.setFromEuler(euler); // orient the device
                quaternion.multiply(q1); // camera looks out the back of the device, not the top
                quaternion.multiply(q0.setFromAxisAngle(zee, -orient)); // adjust for screen orientation
            }
            
            dispose() {
                window.removeEventListener('deviceorientation', this.onDeviceOrientationChangeEvent);
                window.removeEventListener('orientationchange', this.onScreenOrientationChangeEvent);
            }
        }

        // --------------------------------------------------------------------------
        // MAIN APPLICATION LOGIC
        // --------------------------------------------------------------------------
        
        const video = document.getElementById('camera-feed');
        const canvas = document.getElementById('ar-overlay');
        const debug = document.getElementById('debug');
        const btnStart = document.getElementById('btn-start');

        let scene, camera, renderer, controls;
        let floorPlane;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // LOGGING
        function log(msg) { debug.innerText += '\n' + msg; console.log(msg); }

        // 1. INIT CAMERA (VIDEO)
        async function initCamera() {
            try {
                // Request back camera with specific constraints for better performance on old phones
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 640 }, // Lower res is faster on old phones
                        height: { ideal: 480 } 
                    },
                    audio: false
                });
                video.srcObject = stream;
                video.play();
                log("Camera started (640x480 mode).");
            } catch (e) {
                log("Camera Error: " + e.message);
                log("Ensure HTTPS is used.");
            }
        }

        // 2. INIT THREE.JS WORLD
        function initThree() {
            scene = new THREE.Scene();

            // FOV 80 is wider, better matches mobile camera lenses
            camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: false }); // Antialias off for performance
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance

            // Lighting
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            // THE FLOOR
            // We create a mathematical plane at Y = -1.6 (Average eye-level to floor is 1.6 meters)
            floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 1.6);
            
            // Helper grid (Optional: Helps visualizing the floor logic)
            // const grid = new THREE.GridHelper(20, 20);
            // grid.position.y = -1.6;
            // scene.add(grid);

            animate();
        }

        // 3. START SENSORS (The "Algorithm")
        btnStart.addEventListener('click', () => {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(res => {
                    if (res === 'granted') startControls();
                    else log("Sensor Permission Denied");
                }).catch(e => log(e));
            } else {
                startControls();
            }
        });

        function startControls() {
            controls = new DeviceOrientationControls(camera);
            btnStart.style.display = 'none';
            log("Sensors Active. Stabilization On.");
            
            // Optional: Get GPS location just to log it (User requested functionality)
            if("geolocation" in navigator) {
                navigator.geolocation.getCurrentPosition((pos) => {
                    log(`GPS: ${pos.coords.latitude.toFixed(4)}, ${pos.coords.longitude.toFixed(4)}`);
                });
            }
        }

        // 4. CLICK TO PLACE (The "Cheese on Bread" Logic)
        window.addEventListener('touchstart', (e) => {
            if (!controls) return;

            // 1. Get touch coordinates
            const t = e.changedTouches[0];
            mouse.x = (t.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(t.clientY / window.innerHeight) * 2 + 1;

            // 2. Cast ray from camera
            raycaster.setFromCamera(mouse, camera);

            // 3. Intersect with the Virtual Floor
            const target = new THREE.Vector3();
            const hit = raycaster.ray.intersectPlane(floorPlane, target);

            if (hit) {
                createMarker(target);
            } else {
                log("Missed floor (Too high/horizon)");
            }
        }, { passive: false });

        function createMarker(position) {
            // Create the square
            const geometry = new THREE.PlaneGeometry(0.5, 0.5); // 50cm square
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                side: THREE.DoubleSide,
                opacity: 0.8,
                transparent: true
            });
            const mesh = new THREE.Mesh(geometry, material);

            // STICKING LOGIC:
            // 1. Position exactly at intersection
            mesh.position.copy(position);
            
            // 2. Rotate -90deg on X to lay flat on the floor
            mesh.rotation.x = -Math.PI / 2;
            
            // 3. Add to scene (World Space), NOT camera
            scene.add(mesh);

            log(`Square Placed: ${position.x.toFixed(1)}, ${position.z.toFixed(1)}`);
        }

        // 5. RENDER LOOP
        function animate() {
            requestAnimationFrame(animate);

            if (controls) {
                controls.update();
            }

            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        initCamera();
        initThree();

    </script>
</body>
</html>

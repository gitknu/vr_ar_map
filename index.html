<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Offline Map & AR Precision Tool</title>
    
    <!-- AR Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        /* GLOBAL RESET */
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            margin: 0; padding: 0; 
            height: 100vh; width: 100vw; 
            overflow: hidden; 
            background: #222;
        }

        /* =========================================
           MAP APP STYLES 
           ========================================= */
        #map-app-wrapper {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            background: white;
            z-index: 10;
        }

        /* UI CONTROLS */
        #controls { 
            padding: 15px; background: #222; color: white; 
            display: flex; gap: 15px; align-items: center; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 2000;
            flex-wrap: wrap; 
            flex-shrink: 0;
        }
        .group { display: flex; align-items: center; gap: 8px; border-right: 1px solid #555; padding-right: 15px; position: relative; }
        .group:last-child { border-right: none; }
        
        h1 { font-size: 18px; margin: 0; color: #fff; }
        
        button { 
            padding: 8px 16px; cursor: pointer; font-weight: bold; border-radius: 4px; border: none; 
            transition: background 0.2s;
        }
        #btn-download { background: #007bff; color: white; }
        #btn-download:hover { background: #0056b3; }
        #btn-download:disabled { background: #555; cursor: not-allowed; }

        #btn-save-file { background: #6c757d; color: white; display: none; }
        #btn-save-file:hover { background: #5a6268; }

        #btn-loc { background: #17a2b8; color: white; }
        #btn-loc:hover { background: #138496; }
        
        #btn-img-upload { background: #6f42c1; color: white; }
        #btn-img-upload:hover { background: #59359a; }
        
        #btn-img-close { background: #e83e8c; color: white; display: none; }
        #btn-img-close:hover { background: #d63384; }

        #btn-clear { background: #dc3545; color: white; font-size: 12px; padding: 5px 10px;}
        #btn-import { background: #28a745; color: white; font-size: 12px; padding: 5px 10px;}

        /* AR TOGGLE BUTTON */
        #btn-ar-mode { background: #9d00ff; color: white; box-shadow: 0 0 10px #9d00ff; }
        #btn-ar-mode:hover { background: #7a00cc; }

        /* ROUTE BUTTON */
        #btn-route { background: #fd7e14; color: white; }
        #btn-route:hover { background: #e36a09; }
        .routing-active { outline: 3px solid white; box-shadow: 0 0 10px #fd7e14; }

        /* SEARCH STYLES */
        #search-input { padding: 8px; border-radius: 4px; border: none; width: 220px; }
        #btn-search { background: #ffc107; color: #222; }
        #btn-search:hover { background: #e0a800; }

        /* AUTOCOMPLETE DROPDOWN */
        #search-suggestions {
            position: absolute;
            top: 100%; left: 0; width: 100%;
            background: white;
            border-radius: 0 0 4px 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 3000;
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }
        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
            color: #333;
            border-bottom: 1px solid #eee;
            font-size: 13px;
        }
        .suggestion-item:last-child { border-bottom: none; }
        .suggestion-item:hover { background-color: #f0f0f0; }
        
        /* SWITCH TOGGLE */
        .switch-container { display: flex; align-items: center; gap: 10px; background: #444; padding: 5px 10px; border-radius: 20px; }
        .switch-label { font-size: 14px; font-weight: bold; }
        .toggle-checkbox { height: 0; width: 0; visibility: hidden; position: absolute; }
        .toggle-label {
            cursor: pointer; text-indent: -9999px; width: 40px; height: 20px; background: grey; display: block;
            border-radius: 100px; position: relative;
        }
        .toggle-label:after {
            content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: #fff; border-radius: 90px; transition: 0.3s;
        }
        .toggle-checkbox:checked + .toggle-label { background: #28a745; }
        .toggle-checkbox:checked + .toggle-label:after { left: calc(100% - 2px); transform: translateX(-100%); }

        /* STATUS BAR */
        #status-bar { background: #f8f9fa; border-bottom: 1px solid #ddd; padding: 5px 15px; font-size: 12px; color: #333; font-family: monospace; flex-shrink: 0;}

        /* MAP AREA */
        #map { flex-grow: 1; background: #e5e3df; cursor: crosshair; width: 100%; }

        /* TILE STYLES */
        .cached-tile {
            outline: 2px solid rgba(40, 167, 69, 0.6);
            outline-offset: -2px;
            filter: sepia(0.2) hue-rotate(80deg);
        }

        /* =========================================
           AR APP STYLES 
           ========================================= */
        #ar-app-wrapper {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000;
            display: none; /* Hidden by default */
            z-index: 5000;
        }

        /* CAMERA & CANVAS */
        #camera-feed {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            min-width: 100%; min-height: 100%;
            width: auto; height: auto;
            z-index: 0; object-fit: cover;
            filter: contrast(1.1) brightness(1.1);
        }
        #ar-overlay {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%; z-index: 2;
            background: transparent;
        }

        /* HUD ELEMENTS */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 40px; height: 40px;
            transform: translate(-50%, -50%);
            z-index: 5; pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: #00ff00; box-shadow: 0 0 4px #000;
        }
        #crosshair::before { top: 19px; left: 0; width: 40px; height: 2px; }
        #crosshair::after { top: 0; left: 19px; width: 2px; height: 40px; }
        
        #speed-warning {
            position: absolute; top: 150px; left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.8);
            color: white; padding: 10px 20px;
            border-radius: 5px; font-weight: bold;
            z-index: 100; display: none;
            animation: blink 0.5s infinite;
            border: 2px solid white;
        }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        /* LOCK INDICATOR - Dynamic Colors */
        #lock-indicator {
            position: absolute; top: 50%; left: 50%;
            width: 80px; height: 80px;
            transform: translate(-50%, -50%);
            border: 2px dashed cyan;
            border-radius: 50%;
            z-index: 4; opacity: 0;
            transition: opacity 0.2s, border-color 0.2s;
            box-shadow: 0 0 15px cyan;
            pointer-events: none;
        }
        #lock-indicator.locked { 
            opacity: 1; 
            border-style: solid;
            transform: translate(-50%, -50%) scale(1.0); 
            border-color: #00ff00; /* Default GREEN */
            box-shadow: 0 0 15px #00ff00;
        }
        /* New Silhouette Style */
        #lock-indicator.locked-silhouette {
            border-color: #FF9500 !important; /* ORANGE */
            box-shadow: 0 0 15px #FF9500 !important;
        }

        #guide-arrow {
            position: absolute; top: 35%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px; color: rgba(255, 255, 0, 0.8);
            z-index: 4; display: none;
            text-shadow: 0 0 10px black;
            animation: bounce 1s infinite;
        }
        @keyframes bounce { 0%, 100% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -60%) scale(1.1); } }

        /* Snapshot Strip */
        #snapshot-strip {
            position: absolute; top: 10px; left: 0; width: 100%; height: 70px;
            z-index: 20; display: flex; align-items: center; 
            overflow-x: auto; padding-left: 50%; 
            scroll-behavior: smooth;
            pointer-events: none;
        }
        #snapshot-strip::-webkit-scrollbar { display: none; }
        
        .snap-thumb {
            height: 50px; width: 50px; min-width: 50px; object-fit: cover;
            border: 1px solid #444; border-radius: 6px; background: #000; 
            opacity: 0.5; margin: 0 4px; transition: all 0.3s;
        }
        .snap-thumb.active-lock { 
            border-color: #00ff00; opacity: 1; 
            transform: scale(1.2); box-shadow: 0 0 10px #00ff00; 
            z-index: 22;
        }
        /* Orange border for silhouette match on thumb */
        .snap-thumb.active-lock-sil {
            border-color: #FF9500; opacity: 1;
            transform: scale(1.2); box-shadow: 0 0 10px #FF9500;
        }

        /* SIZE SLIDER */
        #slider-container {
            position: absolute; top: 120px; right: 10px;
            width: 30px; height: 180px; z-index: 20;
            display: flex; align-items: center; justify-content: center;
        }
        input[type=range][orient=vertical] {
            writing-mode: bt-lr; -webkit-appearance: slider-vertical;
            width: 8px; height: 100%; padding: 0 5px;
        }
        #size-slider {
            transform: rotate(-90deg); width: 160px; margin: 0;
            background: rgba(255,255,255,0.2); border-radius: 5px; cursor: pointer;
        }
        #slider-label {
            position: absolute; top: 100px; right: 15px;
            color: #00ffff; font-size: 12px; font-weight: bold;
            z-index: 20; pointer-events: none; text-shadow: 1px 1px 2px black;
        }

        /* AR UI CONTROLS */
        #ui-layer {
            position: absolute; bottom: 30px; left: 0; width: 100%;
            z-index: 10; display: flex; flex-direction: column; align-items: center;
            pointer-events: none;
        }
        #panel {
            background: rgba(10, 10, 10, 0.9); backdrop-filter: blur(10px);
            padding: 20px; border-radius: 20px; text-align: center;
            border: 1px solid rgba(255,255,255,0.15); width: 85%; max-width: 400px;
            pointer-events: auto; transition: all 0.3s;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        #progress-container {
            width: 100%; height: 4px; background: #333; margin-bottom: 15px;
            border-radius: 2px; overflow: hidden;
        }
        #progress-fill {
            height: 100%; width: 0%; background: #00ff00; 
            transition: width 0.3s;
        }

        #lbl-step { color: #00ff00; font-size: 14px; font-weight: bold; text-transform: uppercase; margin-bottom: 5px; display: block; letter-spacing: 1px; }
        #lbl-desc { color: #ddd; font-size: 15px; margin-bottom: 20px; display: block; line-height: 1.4; }
        
        .ar-btn {
            background: #fff; color: #000; border: none; padding: 14px 0;
            font-size: 16px; font-weight: 800; border-radius: 8px; cursor: pointer;
            text-transform: uppercase; width: 100%;
            box-shadow: 0 4px 0 #ccc; transition: transform 0.1s, box-shadow 0.1s;
        }
        .ar-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #ccc; }
        
        #btn-action { background: #00ff00; box-shadow: 0 4px 0 #00aa00; }
        #btn-action:active { box-shadow: 0 0 0 #00aa00; }
        
        #final-controls {
            display: none; width: 100%; flex-direction: row; justify-content: space-between; gap: 10px; margin-top: 10px;
        }

        #btn-fix { background: #FF9500; color: white; font-size: 13px; box-shadow: 0 4px 0 #cc7a00; flex: 1; }
        #btn-fix:active { box-shadow: 0 0 0 #cc7a00; }

        #btn-reset { background: #ff3333; color: white; font-size: 13px; box-shadow: 0 4px 0 #cc0000; flex: 1; }
        #btn-reset:active { box-shadow: 0 0 0 #cc0000; }

        #debug {
            position: absolute; top: 160px; left: 10px;
            color: lime; font-size: 10px; z-index: 20;
            background: rgba(0,0,0,0.6); padding: 5px; pointer-events: none;
            white-space: pre-wrap; border-radius: 4px;
        }

        /* RETURN TO MAP BUTTON */
        #btn-back-map {
            position: absolute; top: 15px; left: 15px; 
            background: #fff; color: #000; padding: 8px 12px;
            font-weight: bold; border-radius: 4px; border: 2px solid #000;
            z-index: 50; cursor: pointer;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        #btn-back-map:hover { background: #eee; }

        /* VISUALIZER (MINI-MAP) - Shifted down slightly to avoid back button */
        #mini-map-container {
            position: absolute; top: 60px; left: 15px;
            width: 120px; height: 120px;
            z-index: 30; pointer-events: none;
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #00ff00;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }
        #mini-map { width: 100%; height: 100%; border-radius: 8px; }
        #mini-label { position: absolute; bottom: 2px; right: 4px; color: #00ff00; font-size: 9px; font-weight: bold; opacity: 0.8; }

    </style>
</head>
<body>

<!-- ======================================================================= -->
<!-- APP 1: MAP INTERFACE -->
<!-- ======================================================================= -->
<div id="map-app-wrapper">
    <div id="controls">
        <div class="group">
            <h1>–û—Ñ–ª–∞–π–Ω-–ö–∞—Ä—Ç–∞</h1>
        </div>

        <div class="group">
            <div class="switch-container">
                <span class="switch-label">–û–ù–õ–ê–ô–ù</span>
                <input type="checkbox" id="mode-toggle" class="toggle-checkbox" onchange="toggleMode()">
                <label for="mode-toggle" class="toggle-label">Toggle</label>
                <span class="switch-label">–¢–Ü–õ–¨–ö–ò –û–§–õ–ê–ô–ù</span>
            </div>
        </div>

        <div class="group">
            <input type="text" id="search-input" placeholder="–ü–æ—à—É–∫ (–≤—É–ª–∏—Ü—è, –º—ñ—Å—Ü–µ)..." 
                   oninput="handleSearchInput(this)" 
                   onkeypress="handleSearchEnter(event)"
                   autocomplete="off">
            <button id="btn-search" onclick="doSearch()">üîç</button>
            <div id="search-suggestions"></div>
        </div>

        <div class="group">
            <button id="btn-route" onclick="toggleRouteMode()">üîó –ú–∞—Ä—à—Ä—É—Ç</button>
            <input type="file" id="img-input" accept="image/*" style="display: none;" onchange="handleImageUpload(this)">
            <button id="btn-img-upload" onclick="document.getElementById('img-input').click()">üñºÔ∏è –§–æ—Ç–æ</button>
            <button id="btn-img-close" onclick="closeImageMap()">‚úï</button>
        </div>

        <div class="group">
            <button id="btn-loc" onclick="checkLocation()">üìç –Ø —Ç—É—Ç</button>
            <button id="btn-download" onclick="startDownload()">‚¨áÔ∏è –ó–æ–Ω–∞</button>
            <button id="btn-save-file" onclick="exportLastDownload()">üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ —É —Ñ–∞–π–ª</button>
        </div>
        
        <!-- NEW AR BUTTON -->
        <div class="group">
            <button id="btn-ar-mode" onclick="switchToAR()">üëÅÔ∏è AR Mode</button>
        </div>

        <div class="group" style="margin-left: auto;">
            <input type="file" id="zip-input" accept=".mapzip,.zip" style="display: none;" onchange="importMapArchive(this)">
            <button id="btn-import" onclick="document.getElementById('zip-input').click()">üìÅ –Ü–º–ø–æ—Ä—Ç</button>
            <button id="btn-clear" onclick="clearData()">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç–∏</button>
        </div>
    </div>

    <div id="status-bar">–ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º–∏...</div>
    <div id="map"></div>
</div>

<!-- ======================================================================= -->
<!-- APP 2: AR INTERFACE -->
<!-- ======================================================================= -->
<div id="ar-app-wrapper">
    <!-- Return Button -->
    <button id="btn-back-map" onclick="switchToMap()">‚¨Ö MAP</button>

    <video id="camera-feed" playsinline muted></video>
    <canvas id="ar-overlay"></canvas>
    
    <div id="speed-warning">–£–ü–û–í–Ü–õ–¨–ù–Ü–¢–¨–°–Ø: –ó–ê–ù–ê–î–¢–û –®–í–ò–î–ö–û</div>

    <div id="mini-map-container">
        <canvas id="mini-map"></canvas>
        <div id="mini-label">–ü–û–¢–†–Ü–ë–ù–ò–ô –†–ê–ö–£–†–°</div>
    </div>

    <div id="crosshair"></div>
    <div id="lock-indicator"></div>
    <div id="guide-arrow">‚¨Ü</div>
    <div id="debug">–°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞.</div>
    
    <div id="snapshot-strip"></div>

    <div id="slider-label">–†–û–ó–ú–Ü–†</div>
    <div id="slider-container">
        <input type="range" id="size-slider" min="0.05" max="0.95" step="0.005" value="0.1">
    </div>

    <div id="ui-layer">
        <div id="panel">
            <div id="progress-container"><div id="progress-fill"></div></div>
            <span id="lbl-step">–Ü–ù–Ü–¶–Ü–ê–õ–Ü–ó–ê–¶–Ü–Ø</span>
            <span id="lbl-desc">–ö–∞–ª—ñ–±—Ä—É–≤–∞–Ω–Ω—è —Å–µ–Ω—Å–æ—Ä—ñ–≤.</span>
            
            <button id="btn-action" class="ar-btn">–ü–û–ß–ê–¢–ò –°–ö–ê–ù</button>
            
            <div id="final-controls">
                <button id="btn-fix" class="ar-btn">–¶–ï–ù–¢–†–£–í–ê–¢–ò</button>
                <button id="btn-reset" class="ar-btn">–ü–ï–†–ï–ö–ê–õ–Ü–ë–†–£–í–ê–¢–ò</button>
            </div>
        </div>
    </div>
</div>

<!-- ======================================================================= -->
<!-- LOGIC -->
<!-- ======================================================================= -->
<script>
    // --- GLOBAL STATE ---
    let appMode = 'map'; // 'map' or 'ar'

    // ==========================================
    // PART 1: MAP LOGIC
    // ==========================================
    const CDN_CSS = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
    const CDN_JS = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
    const CDN_JSZIP = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
    
    let map = null, db = null, isOfflineOnly = false, tileLayer = null, searchDebounce = null;
    let noConnectionStart = 0, customMapImage = null, customMapBounds = null, isCustomImageMode = false;
    let isRoutingMode = false, routePoints = [], routeLayer = null, routeMarkers = [];
    let lastDownloadedBounds = null; 

    async function boot() {
        updateStatus("–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–µ—à—É –±—ñ–±–ª—ñ–æ—Ç–µ–∫...");
        let css = localStorage.getItem('lib_css'), js = localStorage.getItem('lib_js'), jszip = localStorage.getItem('lib_jszip');
        if (!css || !js || !jszip) {
            updateStatus("–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –±—ñ–±–ª—ñ–æ—Ç–µ–∫...");
            try {
                const [cssRes, jsRes, zipRes] = await Promise.all([fetch(CDN_CSS), fetch(CDN_JS), fetch(CDN_JSZIP)]);
                css = await cssRes.text(); js = await jsRes.text(); jszip = await zipRes.text();
                localStorage.setItem('lib_css', css); localStorage.setItem('lib_js', js); localStorage.setItem('lib_jszip', jszip);
            } catch (e) { updateStatus("–ü–û–ú–ò–õ–ö–ê –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –±—ñ–±–ª—ñ–æ—Ç–µ–∫."); return; }
        }
        const styleTag = document.createElement('style'); styleTag.textContent = css; document.head.appendChild(styleTag);
        const zipTag = document.createElement('script'); zipTag.textContent = jszip; document.body.appendChild(zipTag);
        const scriptTag = document.createElement('script'); scriptTag.textContent = js; document.body.appendChild(scriptTag);
        setTimeout(initMapApp, 200);
        document.addEventListener('click', e => { if (!e.target.closest('#search-suggestions') && e.target.id !== 'search-input') document.getElementById('search-suggestions').style.display = 'none'; });
        initAutoOfflineProtection();
    }

    function initMapApp() {
        if (typeof L === 'undefined' || typeof JSZip === 'undefined') return setTimeout(initMapApp, 100);
        const request = indexedDB.open("StrictOfflineDB", 14);
        request.onupgradeneeded = e => {
            db = e.target.result;
            if (!db.objectStoreNames.contains("tiles")) db.createObjectStore("tiles", { keyPath: "key" });
            if (!db.objectStoreNames.contains("search_cache")) db.createObjectStore("search_cache", { keyPath: "query" });
            if (!db.objectStoreNames.contains("routes_cache")) db.createObjectStore("routes_cache", { keyPath: "key" });
        };
        request.onsuccess = e => { db = e.target.result; updateStatus("–ì–æ—Ç–æ–≤–æ. –û–Ω–ª–∞–π–Ω."); initMap(); };
    }

    function initMap() {
        map = L.map('map').setView([50.4501, 30.5234], 13);
        map.on('click', onMapClick);
        L.TileLayer.Smart = L.TileLayer.extend({
            createTile: function(coords, done) {
                const tile = document.createElement('img'), key = `${coords.z}_${coords.x}_${coords.y}`;
                L.DomEvent.on(tile, 'load', L.Util.bind(this._tileOnLoad, this, done, tile));
                L.DomEvent.on(tile, 'error', L.Util.bind(this._tileOnError, this, done, tile));
                if (isCustomImageMode && customMapImage && customMapBounds) {
                    const url = getTileFromCustomImage(coords);
                    if (url) { tile.src = url; tile.classList.add('cached-tile'); return tile; }
                }
                const tx = db.transaction("tiles", "readonly");
                tx.objectStore("tiles").get(key).onsuccess = e => {
                    if (e.target.result?.blob) { tile.src = URL.createObjectURL(e.target.result.blob); tile.classList.add('cached-tile'); }
                    else if (isOfflineOnly) tile.src = "data:image/svg+xml;base64," + btoa('<svg xmlns="http://www.w3.org/2000/svg" width="256" height="256"><rect width="256" height="256" fill="#f0f0f0"/><text x="128" y="128" font-family="Arial" font-size="20" fill="#999" text-anchor="middle">OFFLINE</text></svg>');
                    else tile.src = `https://tile.openstreetmap.org/${coords.z}/${coords.x}/${coords.y}.png`;
                };
                return tile;
            }
        });
        tileLayer = new L.TileLayer.Smart(null, { maxZoom: 18 }).addTo(map);
    }

    function initAutoOfflineProtection() {
        setInterval(async () => {
            if (isOfflineOnly) { noConnectionStart = 0; return; }
            let isConnected = navigator.onLine;
            if (isConnected) {
                try {
                    const ctrl = new AbortController(); setTimeout(() => ctrl.abort(), 2000);
                    await fetch('https://tile.openstreetmap.org/0/0/0.png', { method: 'HEAD', signal: ctrl.signal, cache: 'no-store' });
                } catch (e) { isConnected = false; }
            }
            if (!isConnected) {
                if (noConnectionStart === 0) noConnectionStart = Date.now();
                else if (Date.now() - noConnectionStart > 15000) {
                    document.getElementById('mode-toggle').checked = true; toggleMode(); noConnectionStart = 0;
                    alert("–Ü–Ω—Ç–µ—Ä–Ω–µ—Ç –≤—ñ–¥—Å—É—Ç–Ω—ñ–π >15—Å. –ü–µ—Ä–µ—Ö—ñ–¥ –≤ –æ—Ñ–ª–∞–π–Ω.");
                }
            } else noConnectionStart = 0;
        }, 5000);
    }

    async function startDownload() {
        const btn = document.getElementById('btn-download'), b = map.getBounds();
        document.getElementById('btn-save-file').style.display = 'none';
        let queue = [];
        for (let z = 0; z <= 18; z++) {
             const y1 = lat2tile(b.getNorth(), z), y2 = lat2tile(b.getSouth(), z), x1 = long2tile(b.getWest(), z), x2 = long2tile(b.getEast(), z);
             for (let x = x1; x <= x2; x++) for (let y = y1; y <= y2; y++) queue.push({z, x, y});
        }
        const total = queue.length;
        let asArchive = false;
        if (total > 5000) { if (!confirm(`–ó–æ–Ω–∞ ${total} —Ç–∞–π–ª—ñ–≤. –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —è–∫ –∞—Ä—Ö—ñ–≤ (.mapzip)?`)) return; asArchive = true; }
        
        btn.disabled = true;
        const metadataCount = await downloadPlacesMetadata(b);
        const zip = asArchive ? new JSZip() : null;
        let saved = 0; const startTime = Date.now();

        for (let i = 0; i < total; i++) {
            const item = queue[i], elapsed = Date.now() - startTime;
            const timeStr = i > 5 ? `~${Math.ceil(((elapsed/(i+1))*(total-i))/60000)} —Ö–≤` : "...";
            updateStatus(`–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è ${i+1}/${total} (${timeStr})...`);
            try {
                const r = await fetch(`https://tile.openstreetmap.org/${item.z}/${item.x}/${item.y}.png`);
                if(r.ok) {
                    const blob = await r.blob(), key = `${item.z}_${item.x}_${item.y}`;
                    if (asArchive) zip.file(`${key}.png`, blob);
                    else await db.transaction("tiles", "readwrite").objectStore("tiles").put({ key, blob });
                    saved++;
                }
            } catch(e) {}
            if (i % 25 === 0) await new Promise(r => setTimeout(r, 10));
        }

        if (asArchive) {
            updateStatus("–ó–±—ñ—Ä–∫–∞ –∞—Ä—Ö—ñ–≤—É...");
            const searchData = await getSearchDataInBounds(b);
            zip.file("metadata.json", JSON.stringify(searchData));
            const content = await zip.generateAsync({type:"blob"});
            saveBlob(content, `map_${Date.now()}.mapzip`);
            updateStatus("–ê—Ä—Ö—ñ–≤ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ.");
        } else {
            lastDownloadedBounds = b;
            document.getElementById('btn-save-file').style.display = 'inline-block';
            updateStatus(`–ì–æ—Ç–æ–≤–æ! ${saved} —Ç–∞–π–ª—ñ–≤ –∑–±–µ—Ä–µ–∂–µ–Ω–æ.`);
        }
        btn.disabled = false; tileLayer.redraw();
    }

    async function exportLastDownload() {
        if (!lastDownloadedBounds) return;
        updateStatus("–ü—ñ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ñ–∞–π–ª—É...");
        const zip = new JSZip(), b = lastDownloadedBounds;
        const tx = db.transaction("tiles", "readonly"), store = tx.objectStore("tiles");
        let count = 0;
        for (let z = 0; z <= 18; z++) {
            const y1 = lat2tile(b.getNorth(), z), y2 = lat2tile(b.getSouth(), z), x1 = long2tile(b.getWest(), z), x2 = long2tile(b.getEast(), z);
            for (let x = x1; x <= x2; x++) for (let y = y1; y <= y2; y++) {
                const key = `${z}_${x}_${y}`;
                const res = await new Promise(r => { store.get(key).onsuccess = e => r(e.target.result); });
                if (res?.blob) { zip.file(`${key}.png`, res.blob); count++; }
            }
        }
        const searchData = await getSearchDataInBounds(b);
        zip.file("metadata.json", JSON.stringify(searchData));
        const content = await zip.generateAsync({type:"blob"});
        saveBlob(content, `export_${count}_tiles.mapzip`);
        updateStatus("–ï–∫—Å–ø–æ—Ä—Ç–æ–≤–∞–Ω–æ!");
    }

    async function importMapArchive(input) {
        if (!input.files?.[0]) return;
        updateStatus("–Ü–º–ø–æ—Ä—Ç...");
        try {
            const zip = await JSZip.loadAsync(input.files[0]);
            let count = 0;
            for (const filename of Object.keys(zip.files)) {
                if (filename.endsWith(".png")) {
                    const blob = await zip.files[filename].async("blob");
                    await db.transaction("tiles", "readwrite").objectStore("tiles").put({ key: filename.replace(".png", ""), blob });
                    count++;
                } else if (filename === "metadata.json") {
                    const data = JSON.parse(await zip.files[filename].async("string"));
                    const tx = db.transaction("search_cache", "readwrite");
                    data.forEach(item => tx.objectStore("search_cache").put(item));
                }
                if (count % 100 === 0) updateStatus(`–Ü–º–ø–æ—Ä—Ç: ${count}...`);
            }
            alert(`–Ü–º–ø–æ—Ä—Ç–æ–≤–∞–Ω–æ ${count} —Ç–∞–π–ª—ñ–≤.`); tileLayer.redraw();
        } catch (e) { alert("–ü–æ–º–∏–ª–∫–∞ —ñ–º–ø–æ—Ä—Ç—É"); }
        input.value = "";
    }

    async function getSearchDataInBounds(bounds) {
        return new Promise(res => {
            db.transaction("search_cache", "readonly").objectStore("search_cache").getAll().onsuccess = e => {
                res(e.target.result.filter(i => bounds.contains([i.lat, i.lon])));
            };
        });
    }

    async function downloadPlacesMetadata(bounds) {
        const q = `[out:json][timeout:60];(nwr["name"](${bounds.getSouth()-0.01},${bounds.getWest()-0.01},${bounds.getNorth()+0.01},${bounds.getEast()+0.01}););out center;`;
        try {
            const r = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(q)}`);
            const d = await r.json();
            const tx = db.transaction("search_cache", "readwrite");
            d.elements.forEach(el => {
                const lat = el.lat || el.center?.lat, lon = el.lon || el.center?.lon;
                if (lat && el.tags?.name) tx.objectStore("search_cache").put({ query: el.tags.name.toLowerCase(), lat, lon, display_name: el.tags.name + " (–û—Ñ–ª–∞–π–Ω)" });
            });
            return d.elements.length;
        } catch(e) { return 0; }
    }

    function handleSearchInput(input) {
        const val = input.value.trim().toLowerCase();
        if(val.length < 2) { document.getElementById('search-suggestions').style.display = 'none'; return; }
        clearTimeout(searchDebounce);
        searchDebounce = setTimeout(() => {
            db.transaction("search_cache", "readonly").objectStore("search_cache").getAll().onsuccess = e => {
                const matches = e.target.result.filter(x => x.query.includes(val)).slice(0, 10);
                const list = document.getElementById('search-suggestions');
                list.innerHTML = '';
                if (!matches.length) { list.style.display = 'none'; return; }
                matches.forEach(item => {
                    const div = document.createElement('div'); div.className = 'suggestion-item'; div.innerHTML = `üìç ${item.display_name}`;
                    div.onclick = () => { document.getElementById('search-input').value = item.display_name.split('(')[0].trim(); moveToLocation(item.lat, item.lon, item.display_name); list.style.display = 'none'; };
                    list.appendChild(div);
                });
                list.style.display = 'block';
            };
        }, 300);
    }

    function doSearch() {
        const q = document.getElementById('search-input').value.trim().toLowerCase();
        db.transaction("search_cache", "readonly").objectStore("search_cache").get(q).onsuccess = e => {
            if (e.target.result) moveToLocation(e.target.result.lat, e.target.result.lon, e.target.result.display_name);
            else if (!isOfflineOnly) searchOnline(q);
        };
    }

    async function searchOnline(query) {
        const r = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`);
        const d = await r.json();
        if (d?.[0]) {
            moveToLocation(d[0].lat, d[0].lon, d[0].display_name);
            db.transaction("search_cache", "readwrite").objectStore("search_cache").put({ query, lat: d[0].lat, lon: d[0].lon, display_name: d[0].display_name });
        }
    }

    function toggleRouteMode() {
        isRoutingMode = !isRoutingMode; const btn = document.getElementById('btn-route');
        if (isRoutingMode) { btn.classList.add('routing-active'); routeMarkers.forEach(m => map.removeLayer(m)); routePoints = []; }
        else btn.classList.remove('routing-active');
    }

    function onMapClick(e) {
        if (!isRoutingMode) return;
        routePoints.push(e.latlng); routeMarkers.push(L.marker(e.latlng).addTo(map));
        if (routePoints.length === 2) { calculateRoute(routePoints[0], routePoints[1]); toggleRouteMode(); }
    }

    async function calculateRoute(s, end) {
        const key = `${s.lat.toFixed(3)},${s.lng.toFixed(3)}_${end.lat.toFixed(3)},${end.lng.toFixed(3)}`;
        db.transaction("routes_cache", "readonly").objectStore("routes_cache").get(key).onsuccess = async e => {
            if (e.target.result) drawRoute(e.target.result.geometry, "–û—Ñ–ª–∞–π–Ω");
            else if (!isOfflineOnly) {
                const r = await fetch(`https://router.project-osrm.org/route/v1/driving/${s.lng},${s.lat};${end.lng},${end.lat}?overview=full&geometries=geojson`);
                const d = await r.json();
                if (d.routes?.[0]) {
                    const geo = d.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
                    drawRoute(geo, `${(d.routes[0].distance/1000).toFixed(1)} –∫–º`);
                    db.transaction("routes_cache", "readwrite").objectStore("routes_cache").put({ key, geometry: geo });
                }
            }
        };
    }

    function drawRoute(g, l) { if (routeLayer) map.removeLayer(routeLayer); routeLayer = L.polyline(g, { color: 'blue', weight: 5 }).addTo(map); map.fitBounds(routeLayer.getBounds()); updateStatus(`–ú–∞—Ä—à—Ä—É—Ç: ${l}`); }
    function toggleMode() { isOfflineOnly = document.getElementById('mode-toggle').checked; document.getElementById('btn-download').disabled = isOfflineOnly; tileLayer.redraw(); }
    function checkLocation() { navigator.geolocation.getCurrentPosition(p => moveToLocation(p.coords.latitude, p.coords.longitude, "–í–∏ —Ç—É—Ç")); }
    function moveToLocation(lat, lng, t) { map.setView([lat, lng], 15); L.popup().setLatLng([lat, lng]).setContent(t).openOn(map); }
    function handleImageUpload(i) { if (i.files?.[0]) { const r = new FileReader(); r.onload = e => { const img = new Image(); img.onload = () => { customMapImage = img; const c = map.getCenter(), z = map.getZoom(), s = map.getSize(); const sc = Math.min(s.x/img.naturalWidth, s.y/img.naturalHeight)*0.9; const w = img.naturalWidth*sc/2, h = img.naturalHeight*sc/2, cp = map.project(c,z); customMapBounds = L.latLngBounds(map.unproject(L.point(cp.x-w, cp.y-h), z), map.unproject(L.point(cp.x+w, cp.y+h), z)); isCustomImageMode = true; document.getElementById('btn-img-upload').style.display = 'none'; document.getElementById('btn-img-close').style.display = 'inline-block'; tileLayer.redraw(); }; img.src = e.target.result; }; r.readAsDataURL(i.files[0]); } }
    function closeImageMap() { isCustomImageMode = false; document.getElementById('btn-img-upload').style.display = 'inline-block'; document.getElementById('btn-img-close').style.display = 'none'; tileLayer.redraw(); }
    function saveBlob(b, n) { const a = document.createElement("a"); a.href = URL.createObjectURL(b); a.download = n; a.click(); }
    function clearData() { if(confirm("–û—á–∏—Å—Ç–∏—Ç–∏ –±–∞–∑—É?")) { db.transaction("tiles", "readwrite").objectStore("tiles").clear(); db.transaction("search_cache", "readwrite").objectStore("search_cache").clear(); location.reload(); } }
    function updateStatus(m) { document.getElementById('status-bar').innerText = m; }
    function handleSearchEnter(e) { if(e.key === 'Enter') doSearch(); }
    function long2tile(l,z) { return Math.floor((l+180)/360*Math.pow(2,z)); }
    function lat2tile(l,z)  { return Math.floor((1-Math.log(Math.tan(l*Math.PI/180) + 1/Math.cos(l*Math.PI/180))/Math.PI)/2 *Math.pow(2,z)); }

    // ==========================================
    // PART 2: AR LOGIC
    // ==========================================
    
    // Config
    const CAPTURE_STEPS = [
        { id: 'front',      label: "–ü–æ —Ü–µ–Ω—Ç—Ä—É",       desc: "–°—Ç–∞–Ω—å—Ç–µ –ø–µ—Ä–µ–¥ —Ç–æ—á–∫–æ—é —ñ –∑—Ä–æ–±—ñ—Ç—å —Ñ–æ—Ç–æ.",          arrow: "",          offset: new THREE.Vector3(0, 0, 0) },
        { id: 'left',       label: "–õ—ñ–≤–∏–π —Ä–∞–∫—É—Ä—Å",   desc: "–¢–µ–ø–µ—Ä –∑–ª—ñ–≤–∞. –¢–æ—á–∫–∞ –ø–æ —Ü–µ–Ω—Ç—Ä—É –∫–∞–¥—Ä—É.",    arrow: "‚¨Ö",         offset: new THREE.Vector3(-0.8, 0, 0) },
        { id: 'right',      label: "–ü—Ä–∞–≤–∏–π —Ä–∞–∫—É—Ä—Å",  desc: "–¢–µ–ø–µ—Ä –ø—Ä–∞–≤–∏–π –±—ñ–∫ –∑–∞ —Ç—ñ—î—é –∂ –ª–æ–≥—ñ–∫–æ—é.",        arrow: "‚û°",         offset: new THREE.Vector3(0.8, 0, 0) },
        { id: 'back',       label: "–†–∞–∫—É—Ä—Å –ø–æ–∑–∞–¥—É",  desc: "–í—ñ–∑—å–º—ñ—Ç—å —Ä–∞–∫—É—Ä—Å –∑–∑–∞–¥—É.",        arrow: "‚¨á",         offset: new THREE.Vector3(0, 0, 1.0) },
        { id: 'bot_front',  label: "–ü–æ —Ü–µ–Ω—Ç—Ä—É (–∑–Ω–∏–∑—É)",       desc: "–ü–æ–≤–µ—Ä–Ω—ñ—Ç—å—Å—è –Ω–∞ –ø–æ—á–∞—Ç–æ–∫, –∞–ª–µ –ø—Ä–∏—Å—è–¥—å—Ç–µ.",        arrow: "‚¨á",         offset: new THREE.Vector3(0, -0.6, 0) },
        { id: 'bot_left',   label: "–ó–ª—ñ–≤–∞ (–∑–Ω–∏–∑—É)",  desc: "–ó–∞–ª–∏—à–∞—é—á–∏—Å—å —Å–∏–¥—è—á–∏, —Ä–∞–∫—É—Ä—Å –∑–ª—ñ–≤–∞",        arrow: "‚¨Ö",         offset: new THREE.Vector3(-0.8, -0.6, 0) },
        { id: 'iso_lf',     label: "–ó–≥–æ—Ä–∏-–∑–ª—ñ–≤–∞ –ø–æ–ø–µ—Ä–µ–¥—É",   desc: "–Ü–∑–æ–º–µ—Ç—Ä—ñ—è. –ó–ª—ñ–≤–∞-–∑–≥–æ—Ä–∏ —Å–ø–µ—Ä–µ–¥—É",         arrow: "NO_ARROW",  offset: new THREE.Vector3(-0.5, 0.4, -0.5) },
        { id: 'iso_rf',     label: "–ó–≥–æ—Ä–∏-—Å–ø—Ä–∞–≤–∞ –ø–æ–ø–µ—Ä–µ–¥—É",  desc: "–§–æ—Ç–æ —Å–ø—Ä–∞–≤–∞-–∑–≥–æ—Ä–∏ –ø–æ–ø–µ—Ä–µ–¥—É",                  arrow: "NO_ARROW",  offset: new THREE.Vector3(0.5, 0.4, -0.5) },
        { id: 'iso_lb',     label: "–ó–≥–æ—Ä–∏-–∑–ª—ñ–≤–∞ –ø–æ–∑–∞–¥—É",   desc: "–ê–Ω–∞–ª–æ–≥—ñ—á–Ω–æ –ø–æ–∑–∞–¥—É. –ó–≥–æ—Ä–∏-–∑–ª—ñ–≤–∞",                    arrow: "NO_ARROW",  offset: new THREE.Vector3(-1.0, 0, 0.5) },
        { id: 'iso_rb',     label: "–ó–≥–æ—Ä–∏-—Å–ø—Ä–∞–≤–∞ –ø–æ–∑–∞–¥—É", desc: "–Ü –æ—Å—Ç–∞–Ω–Ω—î. –ó–≥–æ—Ä–∏-—Å–ø—Ä–∞–≤–∞ –ø–æ–∑–∞–¥—É",                   arrow: "NO_ARROW",  offset: new THREE.Vector3(1.0, 0, 0.5) }
    ];
    
    // UPDATED: Standard size, strict thresholds for pixels, generous for edges
    const CV_SCAN_SIZE = 32; 
    const PIXEL_THRESHOLD = 40; // STRICT: Only matches if pixels are very close
    const EDGE_THRESHOLD = 40;  // LOOSE: Matches if silhouette is similar
    const ROTATION_SPEED_THRESHOLD = 0.08;

    // AR Variables
    let scene, camera, renderer, arControls;
    let worldRoot, markerMesh;
    let miniScene, miniCam, miniRenderer, miniTargetMarker;
    let capturedPoints = [], stepIndex = 0, isSetupComplete = false;
    let frameCount = 0, lastVisualFingerprint = null;
    let arInitialized = false;

    // Elements
    const video = document.getElementById('camera-feed');
    const arCanvas = document.getElementById('ar-overlay');
    const debug = document.getElementById('debug');
    const snapStrip = document.getElementById('snapshot-strip');
    const lockIndicator = document.getElementById('lock-indicator');
    const guideArrow = document.getElementById('guide-arrow');
    const speedWarning = document.getElementById('speed-warning');
    const uiStep = document.getElementById('lbl-step');
    const uiDesc = document.getElementById('lbl-desc');
    const btnAction = document.getElementById('btn-action');
    const finalControls = document.getElementById('final-controls');
    const btnFix = document.getElementById('btn-fix');
    const btnReset = document.getElementById('btn-reset');
    const progressFill = document.getElementById('progress-fill');
    const slider = document.getElementById('size-slider');
    const raycaster = new THREE.Raycaster();
    const centerScreen = new THREE.Vector2(0, 0);
    
    // CV Canvas
    const cvCanvas = document.createElement('canvas');
    cvCanvas.width = CV_SCAN_SIZE;
    cvCanvas.height = CV_SCAN_SIZE;
    const cvCtx = cvCanvas.getContext('2d', { willReadFrequently: true });

    class OrientationManager {
        constructor(cam) {
            this.camera = cam;
            this.camera.rotation.reorder('YXZ');
            this.enabled = false;
            this.deviceOrientation = {};
            this.screenOrientation = 0;
            this.targetQ = new THREE.Quaternion();
            this.euler = new THREE.Euler();
            this.q0 = new THREE.Quaternion();
            this.q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); 
            this.zee = new THREE.Vector3(0, 0, 1);
            this.visualCorrectionQ = new THREE.Quaternion();
            this.lastQ = new THREE.Quaternion();
            this.rotationSpeed = 0;
            window.addEventListener('deviceorientation', e => this.deviceOrientation = e);
            window.addEventListener('orientationchange', () => this.screenOrientation = window.orientation || 0);
            this.screenOrientation = window.orientation || 0;
        }
        update() {
            if (!this.enabled || !this.deviceOrientation.alpha) return;
            const alpha = THREE.Math.degToRad(this.deviceOrientation.alpha || 0);
            const beta = THREE.Math.degToRad(this.deviceOrientation.beta || 0);
            const gamma = THREE.Math.degToRad(this.deviceOrientation.gamma || 0);
            const orient = THREE.Math.degToRad(this.screenOrientation);
            this.euler.set(beta, alpha, -gamma, 'YXZ'); 
            this.targetQ.setFromEuler(this.euler); 
            this.targetQ.multiply(this.q1); 
            this.targetQ.multiply(this.q0.setFromAxisAngle(this.zee, -orient));
            let finalQ = this.targetQ.clone();
            finalQ.premultiply(this.visualCorrectionQ); 
            this.rotationSpeed = this.camera.quaternion.angleTo(finalQ);
            this.lastQ.copy(this.camera.quaternion);
            this.camera.quaternion.slerp(finalQ, 0.15); 
        }
        correctDrift(storedSnapshotQ, strength = 0.08) {
            const sensorInv = this.targetQ.clone().invert();
            const drift = storedSnapshotQ.clone().multiply(sensorInv);
            this.visualCorrectionQ.slerp(drift, strength); 
        }
    }

    /**
     * DUAL DATA EXTRACTION
     * 1. Simple Grayscale for Pixel Match
     * 2. Sobel Edge for Silhouette Match
     */
    function extractVisualFingerprint(videoSource) {
        if(videoSource.readyState < 2) return null;
        const vw = videoSource.videoWidth, vh = videoSource.videoHeight;
        if(vw === 0 || vh === 0) return null;
        
        // 1. Draw to canvas
        const minDim = Math.min(vw, vh);
        const sx = (vw - minDim) / 2, sy = (vh - minDim) / 2;
        cvCtx.drawImage(videoSource, sx, sy, minDim, minDim, 0, 0, CV_SCAN_SIZE, CV_SCAN_SIZE);
        
        const frame = cvCtx.getImageData(0, 0, CV_SCAN_SIZE, CV_SCAN_SIZE);
        const data = frame.data;
        const width = CV_SCAN_SIZE;
        const height = CV_SCAN_SIZE;
        const size = width * height;
        
        const pixels = new Uint8Array(size);
        const edges = new Uint8Array(size);

        // 2. Grayscale (Pixels)
        for (let i = 0; i < data.length; i += 4) {
            pixels[i/4] = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
        }

        // 3. Edges (Sobel) - Only for fallback
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                const idx = y * width + x;
                const gx = -1*pixels[idx - width - 1] + 1*pixels[idx - width + 1] +
                           -2*pixels[idx - 1]         + 2*pixels[idx + 1] +
                           -1*pixels[idx + width - 1] + 1*pixels[idx + width + 1];

                const gy = -1*pixels[idx - width - 1] - 2*pixels[idx - width] - 1*pixels[idx - width + 1] +
                            1*pixels[idx + width - 1] + 2*pixels[idx + width] + 1*pixels[idx + width + 1];

                let mag = Math.sqrt(gx*gx + gy*gy);
                if (mag > 255) mag = 255;
                edges[idx] = mag; 
            }
        }
        return { pixels: pixels, edges: edges };
    }

    /**
     * Compare Logic
     */
    function compareFingerprints(fp1, fp2) {
        if(!fp1 || !fp2) return { pixelScore: 999, edgeScore: 999 };
        
        let diffP = 0, diffE = 0;
        const len = fp1.pixels.length;

        for (let i = 0; i < len; i++) {
            diffP += Math.abs(fp1.pixels[i] - fp2.pixels[i]);
            diffE += Math.abs(fp1.edges[i] - fp2.edges[i]);
        }
        
        return { 
            pixelScore: diffP / len,
            edgeScore: diffE / len
        };
    }

    async function initCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } },
                audio: false
            });
            video.srcObject = stream;
            video.play();
        } catch (e) { debug.innerText = "–ü–æ–º–∏–ª–∫–∞ –∫–∞–º–µ—Ä–∏: " + e.message; }
    }

    function stopCamera() {
        if (video.srcObject) {
            video.srcObject.getTracks().forEach(track => track.stop());
            video.srcObject = null;
        }
    }

    function initThree() {
        scene = new THREE.Scene();
        worldRoot = new THREE.Group();
        scene.add(worldRoot);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        renderer = new THREE.WebGLRenderer({ canvas: arCanvas, alpha: true, antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        scene.add(new THREE.AmbientLight(0xffffff, 2));

        // Mini Map
        const miniCanvas = document.getElementById('mini-map');
        miniRenderer = new THREE.WebGLRenderer({ canvas: miniCanvas, alpha: true, antialias: true });
        miniRenderer.setSize(120, 120);
        miniScene = new THREE.Scene();
        const objGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const objMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
        miniScene.add(new THREE.Mesh(objGeo, objMat));
        miniScene.add(new THREE.GridHelper(4, 8, 0x444444, 0x222222));
        const coneGeo = new THREE.ConeGeometry(0.15, 0.4, 8); coneGeo.rotateX(Math.PI / 2);
        miniTargetMarker = new THREE.Mesh(coneGeo, new THREE.MeshBasicMaterial({ color: 0xffff00 }));
        miniTargetMarker.position.set(0, 0, 1.5); miniTargetMarker.lookAt(0,0,0);
        miniScene.add(miniTargetMarker);
        miniCam = new THREE.PerspectiveCamera(50, 1, 0.1, 20);
        miniCam.position.set(2.5, 2.0, 2.5); miniCam.lookAt(0, 0, 0);

        // Bind events
        slider.addEventListener('input', (e) => {
            const newSize = parseFloat(e.target.value);
            if (markerMesh) { markerMesh.scale.set(newSize, newSize, 1); debug.innerText = `–†–æ–∑–º—ñ—Ä: ${(newSize * 100).toFixed(0)}—Å–º`; }
        });
        
        btnAction.addEventListener('click', () => {
            if (stepIndex === 0) {
                if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission().then(res => { if (res === 'granted') startCalibration(); });
                } else startCalibration();
            } else if (stepIndex <= CAPTURE_STEPS.length) captureStep();
        });

        btnFix.addEventListener('click', manualFixLogic);
        btnReset.addEventListener('click', resetCalibration);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        arInitialized = true;
        animate();
    }

    function startCalibration() {
        if (!arControls) arControls = new OrientationManager(camera);
        arControls.enabled = true;
        stepIndex = 1; btnAction.innerText = "–ó–ù–Ü–ú–û–ö"; updateUI();
    }

    function resetCalibration() {
        capturedPoints = []; stepIndex = 0; isSetupComplete = false;
        if(markerMesh) { worldRoot.remove(markerMesh); markerMesh = null; }
        snapStrip.innerHTML = ''; progressFill.style.width = '0%';
        uiStep.innerText = "–Ü–ù–Ü–¶–Ü–ê–õ–Ü–ó–ê–¶–Ü–Ø"; uiDesc.innerText = "–ö–∞–ª—ñ–±—Ä—É–≤–∞–Ω–Ω—è —Å–µ–Ω—Å–æ—Ä—ñ–≤.";
        finalControls.style.display = 'none'; btnAction.style.display = 'block'; btnAction.innerText = "–ü–û–ß–ê–¢–ò –°–ö–ê–ù";
        if(miniTargetMarker) { miniTargetMarker.visible = true; miniTargetMarker.position.set(0, 0, 1.5); }
        debug.innerText = "–°–∏—Å—Ç–µ–º–∞ –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω–∞.";
    }

    function updateUI() {
        if(stepIndex > CAPTURE_STEPS.length) return;
        const cfg = CAPTURE_STEPS[stepIndex - 1];
        uiStep.innerText = `${cfg.label} (${stepIndex}/${CAPTURE_STEPS.length})`;
        uiDesc.innerText = cfg.desc;
        progressFill.style.width = `${((stepIndex - 1) / CAPTURE_STEPS.length) * 100}%`;
        if (miniTargetMarker) {
            if (cfg.offset.lengthSq() === 0) miniTargetMarker.position.set(0, 0, 0.8);
            else miniTargetMarker.position.copy(cfg.offset);
            miniTargetMarker.lookAt(0,0,0);
        }
        if(cfg.arrow && cfg.arrow !== "NO_ARROW") {
            guideArrow.style.display = 'block'; guideArrow.innerText = cfg.arrow;
            guideArrow.style.transform = "translate(-50%, -50%) rotate(0deg)";
        } else guideArrow.style.display = 'none';
    }

    function captureStep() {
        const cfg = CAPTURE_STEPS[stepIndex - 1];
        raycaster.setFromCamera(centerScreen, camera);
        const rawDir = raycaster.ray.direction.clone();
        const currentQuat = camera.quaternion.clone();
        
        const fingerprint = extractVisualFingerprint(video);
        if(!fingerprint) return; 
        
        const canvasSnap = document.createElement('canvas');
        canvasSnap.width = 64; canvasSnap.height = 64;
        const vRatio = video.videoWidth / video.videoHeight;
        let sx=0, sy=0, sWidth=video.videoWidth, sHeight=video.videoHeight;
        if(vRatio > 1) { sx = (video.videoWidth - video.videoHeight)/2; sWidth = video.videoHeight; }
        else { sy = (video.videoHeight - video.videoWidth)/2; sHeight = video.videoWidth; }
        
        canvasSnap.getContext('2d').drawImage(video, sx, sy, sWidth, sHeight, 0, 0, 64, 64);
        const thumbImg = document.createElement('img');
        thumbImg.src = canvasSnap.toDataURL(); thumbImg.className = 'snap-thumb'; thumbImg.id = `thumb-${stepIndex}`;
        snapStrip.appendChild(thumbImg); snapStrip.scrollLeft = snapStrip.scrollWidth;

        capturedPoints.push({ origin: cfg.offset.clone(), direction: rawDir, quaternion: currentQuat, visualData: fingerprint, uiId: `thumb-${stepIndex}` });
        stepIndex++;
        if (stepIndex > CAPTURE_STEPS.length) finalizeSetup(); else updateUI();
    }

    function finalizeSetup() {
        guideArrow.style.display = 'none'; progressFill.style.width = '100%';
        miniTargetMarker.visible = false; calculateIntersection();
        isSetupComplete = true; uiStep.innerText = "–°–¢–ï–ñ–ï–ù–ù–Ø –ê–ö–¢–ò–í–ù–ï";
        uiDesc.innerText = "–ó–∞—Ñ—ñ–∫—Å–æ–≤–∞–Ω–æ. –†—É—Ö–∞–π—Ç–µ—Å—å –≤—ñ–ª—å–Ω–æ.";
        btnAction.style.display = 'none'; finalControls.style.display = 'flex';
    }

    function calculateIntersection() {
        let accumulatedPoint = new THREE.Vector3(0,0,0); let count = 0;
        for (let i = 0; i < capturedPoints.length; i++) {
            for (let j = i + 1; j < capturedPoints.length; j++) {
                const result = closestPointBetweenRays(capturedPoints[i], capturedPoints[j]);
                if (result) { accumulatedPoint.add(result); count++; }
            }
        }
        if (count > 0) accumulatedPoint.divideScalar(count); else accumulatedPoint.set(0, -1.0, -2); 
        placeObject(accumulatedPoint);
    }

    function closestPointBetweenRays(r1, r2) {
        const p1 = r1.origin, d1 = r1.direction, p2 = r2.origin, d2 = r2.direction;
        const n = new THREE.Vector3().crossVectors(d1, d2), n2 = n.lengthSq();
        if (n2 < 0.001) return null;
        const d12 = new THREE.Vector3().subVectors(p2, p1);
        const t = d12.dot(new THREE.Vector3().crossVectors(d2, n)) / n2;
        const u = d12.dot(new THREE.Vector3().crossVectors(d1, n)) / n2;
        return new THREE.Vector3().addVectors(p1.clone().add(d1.clone().multiplyScalar(t)), p2.clone().add(d2.clone().multiplyScalar(u))).multiplyScalar(0.5);
    }

    function placeObject(pos) {
        const geo = new THREE.PlaneGeometry(1, 1); 
        const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
        markerMesh = new THREE.Mesh(geo, mat); markerMesh.rotation.x = -Math.PI / 2;
        const initialSize = parseFloat(slider.value); markerMesh.scale.set(initialSize, initialSize, 1);
        markerMesh.position.copy(pos);
        const box = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent:true, opacity: 0.3}));
        box.position.z = 0.5; markerMesh.add(box); worldRoot.add(markerMesh);
    }

    function manualFixLogic() {
        if(!markerMesh) return;
        raycaster.setFromCamera(centerScreen, camera);
        const groundY = markerMesh.position.y;
        const dir = raycaster.ray.direction, origin = raycaster.ray.origin;
        if (Math.abs(dir.y) < 0.01) return; 
        const t = (groundY - origin.y) / dir.y;
        if (t < 0) return; 
        const hitPoint = new THREE.Vector3().copy(origin).add(dir.multiplyScalar(t));
        markerMesh.position.x = hitPoint.x; markerMesh.position.z = hitPoint.z;
        markerMesh.material.color.setHex(0xFFFFFF); setTimeout(() => markerMesh.material.color.setHex(0x00FFFF), 200);
    }

    function runVisualLocalization() {
        if (!arControls) return;
        const currentFingerprint = extractVisualFingerprint(video);
        
        let visualDelta = 0;
        if (lastVisualFingerprint && currentFingerprint) {
            let diff = 0;
            // Quick Motion Check (using Pixel Match for sensitivity)
            for(let k=0; k<currentFingerprint.pixels.length; k+=4) { 
                diff += Math.abs(currentFingerprint.pixels[k] - lastVisualFingerprint.pixels[k]);
            }
            visualDelta = diff / (currentFingerprint.pixels.length/4);
        }
        lastVisualFingerprint = currentFingerprint;

        if (arControls.rotationSpeed > ROTATION_SPEED_THRESHOLD || visualDelta > 50) speedWarning.style.display = 'block';
        else speedWarning.style.display = 'none';

        if (!isSetupComplete || capturedPoints.length === 0 || frameCount % 5 !== 0) return;

        const currentQ = camera.quaternion;
        let bestMatchDiff = 999;
        let bestMatchIdx = -1;
        let matchType = "NONE";
        
        // --- 1. PRIORITY SEARCH: EXACT PIXEL MATCH (GREEN) ---
        for (let i = 0; i < capturedPoints.length; i++) {
            if (currentQ.angleTo(capturedPoints[i].quaternion) < 0.45) { 
                const scores = compareFingerprints(currentFingerprint, capturedPoints[i].visualData);
                
                // Strict Pixel Check
                if (scores.pixelScore < PIXEL_THRESHOLD) {
                    if (scores.pixelScore < bestMatchDiff) {
                        bestMatchDiff = scores.pixelScore;
                        bestMatchIdx = i;
                        matchType = "EXACT";
                    }
                }
            }
        }

        // --- 2. FALLBACK SEARCH: SILHOUETTE (ORANGE) ---
        // Only if we haven't found an Exact Match yet
        if (matchType === "NONE") {
             for (let i = 0; i < capturedPoints.length; i++) {
                if (currentQ.angleTo(capturedPoints[i].quaternion) < 0.45) { 
                    const scores = compareFingerprints(currentFingerprint, capturedPoints[i].visualData);
                    // Loose Edge Check
                    if (scores.edgeScore < EDGE_THRESHOLD) {
                        if (scores.edgeScore < bestMatchDiff) {
                            bestMatchDiff = scores.edgeScore;
                            bestMatchIdx = i;
                            matchType = "SILHOUETTE";
                        }
                    }
                }
            }
        }

        // --- UI & LOCK LOGIC ---
        document.querySelectorAll('.snap-thumb').forEach(el => {
            el.classList.remove('active-lock');
            el.classList.remove('active-lock-sil');
        });
        
        lockIndicator.classList.remove('locked');
        lockIndicator.classList.remove('locked-silhouette');

        if (bestMatchIdx !== -1) {
            const match = capturedPoints[bestMatchIdx];
            const thumb = document.getElementById(match.uiId);
            
            // Correction Strength
            let strength = 0.08; 
            
            if (matchType === "EXACT") {
                // GREEN CIRCLE LOGIC
                lockIndicator.classList.add('locked');
                if(thumb) thumb.classList.add('active-lock');
                strength = 0.08; // Normal stability
            } else {
                // ORANGE CIRCLE LOGIC
                lockIndicator.classList.add('locked');
                lockIndicator.classList.add('locked-silhouette');
                if(thumb) thumb.classList.add('active-lock-sil');
                strength = 0.15; // Stronger pull to prevent drift
            }

            arControls.correctDrift(match.quaternion, strength);
            
            if (markerMesh) {
                raycaster.setFromCamera(centerScreen, camera);
                const groundY = markerMesh.position.y;
                const dir = raycaster.ray.direction, origin = raycaster.ray.origin;
                if (Math.abs(dir.y) > 0.05) { 
                    const t = (groundY - origin.y) / dir.y;
                    if (t > 0) {
                        const targetPos = new THREE.Vector3().copy(origin).add(dir.multiplyScalar(t));
                        markerMesh.position.x += (targetPos.x - markerMesh.position.x) * 0.1;
                        markerMesh.position.z += (targetPos.z - markerMesh.position.z) * 0.1;
                    }
                }
            }
            debug.innerText = `LOCKED [${matchType}]: #${bestMatchIdx+1} (Diff: ${bestMatchDiff.toFixed(1)})`;
        } else {
            debug.innerText = `Scanning...`;
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        // Only render AR if mode is active to save resources
        if (appMode === 'ar') {
            frameCount++;
            if (arControls) arControls.update();
            runVisualLocalization();
            renderer.render(scene, camera);
            if(miniRenderer) miniRenderer.render(miniScene, miniCam);
        }
    }

    // ==========================================
    // INTEGRATION LOGIC
    // ==========================================
    function switchToAR() {
        appMode = 'ar';
        document.getElementById('map-app-wrapper').style.display = 'none';
        document.getElementById('ar-app-wrapper').style.display = 'block';
        
        // Initialize ThreeJS once
        if (!arInitialized) initThree();
        
        // Start camera
        initCamera();
    }

    function switchToMap() {
        appMode = 'map';
        document.getElementById('ar-app-wrapper').style.display = 'none';
        document.getElementById('map-app-wrapper').style.display = 'flex';
        
        // Stop camera to save battery
        stopCamera();
        
        // Ensure map renders correctly after being hidden
        if(map) map.invalidateSize();
    }

    // Start App 1
    boot();

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Precision AR: Orbit Scan</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: monospace; }
        
        /* CAMERA & CANVAS */
        #camera-feed {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            min-width: 100%; min-height: 100%;
            width: auto; height: auto;
            z-index: 0; object-fit: cover; filter: contrast(1.1);
        }
        #ar-overlay {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%; z-index: 2;
            background: transparent;
        }

        /* HUD ELEMENTS */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            z-index: 10; pointer-events: none;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 9px; left: 9px;
            width: 2px; height: 2px; background: red;
        }

        /* TARGET GUIDE (The "Ghost" Circle) */
        #guide-ring {
            position: absolute; top: 50%; left: 50%;
            width: 60px; height: 60px;
            transform: translate(-50%, -50%);
            border: 4px solid #00ff00;
            border-radius: 50%;
            z-index: 5;
            display: none; /* Controlled by JS */
            box-shadow: 0 0 10px #00ff00;
            transition: width 0.1s, height 0.1s;
        }
        /* Direction Arrows */
        #arrow-left, #arrow-right {
            position: absolute; top: 50%; width: 0; height: 0; 
            border-top: 20px solid transparent; border-bottom: 20px solid transparent;
            z-index: 6; display: none; transform: translateY(-50%);
        }
        #arrow-left { left: 20px; border-right: 30px solid #00ff00; }
        #arrow-right { right: 20px; border-left: 30px solid #00ff00; }

        #lock-indicator {
            position: absolute; top: 50%; left: 50%;
            width: 80px; height: 80px;
            transform: translate(-50%, -50%);
            border: 2px solid cyan; border-radius: 50%;
            z-index: 4; opacity: 0; transition: opacity 0.2s, transform 0.2s;
            box-shadow: 0 0 15px cyan; pointer-events: none;
        }
        #lock-indicator.locked { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }

        /* PROGRESS BAR */
        #progress-container {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 8px; background: rgba(255,255,255,0.2);
            border-radius: 4px; z-index: 20; display: none; overflow: hidden;
        }
        #progress-fill {
            height: 100%; width: 0%; background: #00ff00; 
            transition: width 0.3s;
        }

        /* UI PANELS */
        #ui-layer {
            position: absolute; bottom: 30px; left: 0; width: 100%;
            z-index: 10; display: flex; flex-direction: column; align-items: center;
            pointer-events: none;
        }
        #panel {
            background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(8px);
            padding: 20px; border-radius: 16px; text-align: center;
            border: 1px solid rgba(255,255,255,0.2); width: 85%; max-width: 350px;
            pointer-events: auto; transition: all 0.3s;
        }
        #lbl-status { color: #00ff00; font-size: 14px; font-weight: bold; text-transform: uppercase; margin-bottom: 5px; display: block; }
        #lbl-instruction { color: #fff; font-size: 15px; margin-bottom: 15px; display: block; line-height: 1.4; }
        
        button {
            background: #fff; color: #000; border: none; padding: 12px 30px;
            font-size: 16px; font-weight: 800; border-radius: 30px; cursor: pointer;
            text-transform: uppercase; width: 100%;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); background: #ccc; }
        
        #btn-fix { background: #FF9500; color: white; display: none; margin-top: 10px; font-size: 14px; }

        /* DEBUG & SLIDER */
        #debug {
            position: absolute; top: 5px; left: 5px;
            color: lime; font-size: 10px; z-index: 20;
            background: rgba(0,0,0,0.5); padding: 4px; pointer-events: none;
        }
        #slider-container {
            position: absolute; top: 100px; right: 10px;
            width: 30px; height: 150px; z-index: 20;
            display: flex; align-items: center; justify-content: center;
        }
        input[type=range][orient=vertical] {
            writing-mode: bt-lr; -webkit-appearance: slider-vertical;
            width: 8px; height: 100%; padding: 0 5px;
        }
        #size-slider {
            transform: rotate(-90deg); width: 150px; margin: 0;
            background: rgba(255,255,255,0.2); border-radius: 5px; cursor: pointer;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <video id="camera-feed" playsinline autoplay muted></video>
    <canvas id="ar-overlay"></canvas>
    
    <!-- HUD -->
    <div id="crosshair"></div>
    <div id="guide-ring"></div> <!-- The moving target -->
    <div id="arrow-left"></div> <div id="arrow-right"></div>
    <div id="lock-indicator"></div>
    <div id="progress-container"><div id="progress-fill"></div></div>
    
    <div id="debug">System Ready.</div>

    <div id="slider-container">
        <input type="range" id="size-slider" min="0.05" max="1.0" step="0.01" value="0.2">
    </div>

    <div id="ui-layer">
        <div id="panel">
            <span id="lbl-status">Initialization</span>
            <span id="lbl-instruction">Stand ~1m from object.<br>Tap START and follow the green circle.</span>
            <button id="btn-action">START SCAN</button>
            <button id="btn-fix">MANUAL RE-CENTER</button>
        </div>
    </div>

    <script>
        // --------------------------------------------------------------------------
        // CONFIGURATION
        // --------------------------------------------------------------------------
        const CV_SCAN_SIZE = 32; 
        const VISUAL_THRESHOLD = 30; // Slightly looser to ensure matches
        const ORBIT_RADIUS = 0.5; // Meters
        const ANGLE_TOLERANCE = 0.15; // Radians (~8 degrees)
        
        // --------------------------------------------------------------------------
        // 1. SENSOR FUSION ENGINE
        // --------------------------------------------------------------------------
        class OrientationManager {
            constructor(camera) {
                this.camera = camera;
                this.camera.rotation.reorder('YXZ');
                this.enabled = false;
                this.deviceOrientation = null;
                this.screenOrientation = 0;
                
                this.targetQ = new THREE.Quaternion();
                this.euler = new THREE.Euler();
                this.q0 = new THREE.Quaternion();
                this.q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); 
                this.zee = new THREE.Vector3(0, 0, 1);
                
                this.visualCorrectionQ = new THREE.Quaternion(); 

                window.addEventListener('deviceorientation', e => this.deviceOrientation = e);
                window.addEventListener('orientationchange', () => this.screenOrientation = window.orientation || 0);
                this.screenOrientation = window.orientation || 0;
            }

            update() {
                if (!this.enabled || !this.deviceOrientation || !this.deviceOrientation.alpha) return;

                const alpha = THREE.Math.degToRad(this.deviceOrientation.alpha || 0);
                const beta = THREE.Math.degToRad(this.deviceOrientation.beta || 0);
                const gamma = THREE.Math.degToRad(this.deviceOrientation.gamma || 0);
                const orient = THREE.Math.degToRad(this.screenOrientation);

                this.euler.set(beta, alpha, -gamma, 'YXZ'); 
                this.targetQ.setFromEuler(this.euler); 
                this.targetQ.multiply(this.q1); 
                this.targetQ.multiply(this.q0.setFromAxisAngle(this.zee, -orient));

                let finalQ = this.targetQ.clone();
                finalQ.premultiply(this.visualCorrectionQ); 
                
                this.camera.quaternion.slerp(finalQ, 0.5); // Faster response
            }

            correctDrift(storedSnapshotQ) {
                const sensorInv = this.targetQ.clone().invert();
                const drift = storedSnapshotQ.clone().multiply(sensorInv);
                this.visualCorrectionQ.slerp(drift, 0.05); 
            }
        }

        // --------------------------------------------------------------------------
        // 2. COMPUTER VISION UTILS
        // --------------------------------------------------------------------------
        const cvCanvas = document.createElement('canvas');
        cvCanvas.width = CV_SCAN_SIZE; cvCanvas.height = CV_SCAN_SIZE;
        const cvCtx = cvCanvas.getContext('2d', { willReadFrequently: true });

        function extractVisualFingerprint(videoSource) {
            if(videoSource.readyState < 2) return null;
            const vw = videoSource.videoWidth;
            const vh = videoSource.videoHeight;
            const minDim = Math.min(vw, vh);
            const sx = (vw - minDim) / 2;
            const sy = (vh - minDim) / 2;
            
            cvCtx.drawImage(videoSource, sx, sy, minDim, minDim, 0, 0, CV_SCAN_SIZE, CV_SCAN_SIZE);
            const frame = cvCtx.getImageData(0, 0, CV_SCAN_SIZE, CV_SCAN_SIZE);
            const data = frame.data;
            const grayData = new Uint8Array(CV_SCAN_SIZE * CV_SCAN_SIZE);

            for (let i = 0; i < data.length; i += 4) {
                grayData[i/4] = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
            }
            return grayData;
        }

        function compareFingerprints(fp1, fp2) {
            let diff = 0;
            for (let i = 0; i < fp1.length; i++) {
                diff += Math.abs(fp1[i] - fp2[i]);
            }
            return diff / fp1.length;
        }

        // --------------------------------------------------------------------------
        // 3. APP STATE & GLOBALS
        // --------------------------------------------------------------------------
        const video = document.getElementById('camera-feed');
        const canvas = document.getElementById('ar-overlay');
        const debug = document.getElementById('debug');
        const guideRing = document.getElementById('guide-ring');
        const arrowLeft = document.getElementById('arrow-left');
        const arrowRight = document.getElementById('arrow-right');
        const progressFill = document.getElementById('progress-fill');
        const progressContainer = document.getElementById('progress-container');
        const lockIndicator = document.getElementById('lock-indicator');
        
        const uiStatus = document.getElementById('lbl-status');
        const uiInstr = document.getElementById('lbl-instruction');
        const btnAction = document.getElementById('btn-action');
        const btnFix = document.getElementById('btn-fix');
        const slider = document.getElementById('size-slider');

        let scene, camera, renderer, controls;
        let worldRoot, markerMesh;

        let capturedPoints = []; 
        let isScanning = false;
        let isTracking = false;
        let scanTargets = [];
        let currentTargetIndex = 0;
        let startQuaternion = new THREE.Quaternion(); // CRITICAL: Reference for relative movement
        
        const raycaster = new THREE.Raycaster();
        const centerScreen = new THREE.Vector2(0, 0);

        // --------------------------------------------------------------------------
        // 4. SCANNING LOGIC (Relative Orbit)
        // --------------------------------------------------------------------------
        
        function generateScanTargets() {
            // Yaw (Left/Right), Pitch (Up/Down) relative to START position
            return [
                { yaw: 0, pitch: 0, label: "Hold Center" },
                { yaw: -0.2, pitch: 0, label: "Orbit Left" },
                { yaw: -0.4, pitch: 0, label: "Orbit Left More" },
                { yaw: -0.2, pitch: 0, label: "Return" },
                { yaw: 0, pitch: 0, label: "Center" },
                { yaw: 0.2, pitch: 0, label: "Orbit Right" },
                { yaw: 0.4, pitch: 0, label: "Orbit Right More" },
                { yaw: 0.2, pitch: 0, label: "Return" },
                { yaw: 0, pitch: -0.2, label: "Look Down" },
                { yaw: 0, pitch: 0, label: "Done" }
            ];
        }

        function updateGuideVisuals() {
            if (!isScanning || currentTargetIndex >= scanTargets.length) return;

            const step = scanTargets[currentTargetIndex];
            
            // 1. Calculate Target Rotation in World Space (Relative to Start)
            // Rotate the StartQuaternion by the Step Yaw/Pitch
            const offsetEuler = new THREE.Euler(step.pitch, step.yaw, 0, 'YXZ');
            const offsetQ = new THREE.Quaternion().setFromEuler(offsetEuler);
            const globalTargetQ = startQuaternion.clone().multiply(offsetQ);

            // 2. Check Alignment (Angle between Current Camera Q and Target Q)
            const angleDiff = camera.quaternion.angleTo(globalTargetQ);
            
            // 3. Project Target to Screen for UI
            // Create a point 1 meter in front of the TARGET rotation
            const targetVec = new THREE.Vector3(0, 0, -1).applyQuaternion(globalTargetQ);
            
            // Project this 3D vector onto the 2D camera screen
            // We clone it because project modifies the vector
            const screenVec = targetVec.clone().project(camera); 
            
            // Check if target is behind us
            const camForward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const isInFront = camForward.dot(targetVec) > 0;

            const x = (screenVec.x * 0.5 + 0.5) * window.innerWidth;
            const y = -(screenVec.y * 0.5 - 0.5) * window.innerHeight;

            // UI UPDATES
            uiStatus.innerText = `Point ${currentTargetIndex + 1}/${scanTargets.length}`;
            uiInstr.innerText = step.label;
            progressContainer.style.display = 'block';
            progressFill.style.width = `${(currentTargetIndex / scanTargets.length) * 100}%`;
            
            // ARROWS vs RING
            arrowLeft.style.display = 'none';
            arrowRight.style.display = 'none';
            guideRing.style.display = 'none';

            if (!isInFront) {
                // Completely turned away
                // Rough guess which way to turn
                if (step.yaw < 0) arrowLeft.style.display = 'block';
                else arrowRight.style.display = 'block';
            } else if (screenVec.x < -0.9) {
                arrowLeft.style.display = 'block';
            } else if (screenVec.x > 0.9) {
                arrowRight.style.display = 'block';
            } else {
                // Target is on screen
                guideRing.style.display = 'block';
                guideRing.style.transform = `translate(${x - 30}px, ${y - 30}px)`; // -30 is half of ring size (60)
            }

            // 4. Capture Logic
            if (angleDiff < ANGLE_TOLERANCE) {
                guideRing.style.borderColor = 'white';
                guideRing.style.boxShadow = '0 0 15px white';
                
                if (!step.capturing) {
                    step.capturing = true;
                    // Wait a moment for stability then capture
                    setTimeout(() => {
                        // Re-check alignment before committing
                        if (camera.quaternion.angleTo(globalTargetQ) < ANGLE_TOLERANCE + 0.05) {
                            captureCurrentFrame(step, globalTargetQ);
                            currentTargetIndex++;
                            if (currentTargetIndex >= scanTargets.length) {
                                finishScanning();
                            }
                        }
                        step.capturing = false;
                    }, 400); 
                }
            } else {
                guideRing.style.borderColor = '#00ff00';
                guideRing.style.boxShadow = '0 0 10px #00ff00';
                step.capturing = false;
            }
        }

        function captureCurrentFrame(step, targetQ) {
            const fp = extractVisualFingerprint(video);
            if(!fp) return;

            const q = camera.quaternion.clone();
            raycaster.setFromCamera(centerScreen, camera);
            const dir = raycaster.ray.direction.clone();

            // Parallax Math: Infer position based on Rotation relative to Start
            // angleDiff from Start
            const relativeQ = startQuaternion.clone().invert().multiply(q);
            const relativeEuler = new THREE.Euler().setFromQuaternion(relativeQ, 'YXZ');
            
            const vOffset = new THREE.Vector3();
            // Looking Right (-Y rotation) means I moved Left (-X)
            vOffset.x = Math.sin(relativeEuler.y) * ORBIT_RADIUS; 
            vOffset.z = (1 - Math.cos(relativeEuler.y)) * ORBIT_RADIUS; 
            vOffset.y = Math.sin(relativeEuler.x) * ORBIT_RADIUS;

            capturedPoints.push({
                origin: vOffset,
                direction: dir,
                quaternion: q,
                visualData: fp
            });

            // Flash effect
            const flash = document.createElement('div');
            flash.style.position='fixed'; flash.style.top=0; flash.style.left=0;
            flash.style.width='100%'; flash.style.height='100%';
            flash.style.background='white'; flash.style.opacity='0.4'; flash.style.zIndex='100';
            document.body.appendChild(flash);
            setTimeout(()=>flash.remove(), 100);
        }

        function finishScanning() {
            isScanning = false;
            guideRing.style.display = 'none';
            progressContainer.style.display = 'none';
            uiInstr.innerText = "Processing...";
            
            setTimeout(calculateWorldIntersection, 200);
        }

        function calculateWorldIntersection() {
            let acc = new THREE.Vector3(0,0,0);
            let count = 0;
            
            for(let i=0; i<capturedPoints.length; i++) {
                for(let j=i+1; j<capturedPoints.length; j++) { 
                    const pt = closestPointBetweenRays(capturedPoints[i], capturedPoints[j]);
                    if(pt && pt.z < -0.2 && pt.length() < 5) { // Sanity check
                        acc.add(pt);
                        count++;
                    }
                }
            }

            if(count > 0) acc.divideScalar(count);
            else acc.set(0, -1.0, -2); 

            placeMarker(acc);
            
            isTracking = true;
            uiStatus.innerText = "TRACKING ACTIVE";
            uiInstr.innerText = "Move around. System will auto-correct.";
            btnAction.style.display = 'none';
            btnFix.style.display = 'block';
        }

        function closestPointBetweenRays(r1, r2) {
            const p1 = r1.origin; const d1 = r1.direction;
            const p2 = r2.origin; const d2 = r2.direction;
            const n = new THREE.Vector3().crossVectors(d1, d2);
            const n2 = n.lengthSq();
            if (n2 < 0.0001) return null;
            const d12 = new THREE.Vector3().subVectors(p2, p1);
            const t = d12.dot(new THREE.Vector3().crossVectors(d2, n)) / n2;
            const u = d12.dot(new THREE.Vector3().crossVectors(d1, n)) / n2;
            return new THREE.Vector3().addVectors(p1.clone().add(d1.clone().multiplyScalar(t)), p2.clone().add(d2.clone().multiplyScalar(u))).multiplyScalar(0.5);
        }

        function placeMarker(pos) {
            if(markerMesh) worldRoot.remove(markerMesh);
            const geo = new THREE.PlaneGeometry(1, 1); 
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide, transparent: true, opacity: 0.8, depthTest: false });
            markerMesh = new THREE.Mesh(geo, mat);
            markerMesh.rotation.x = -Math.PI / 2;
            markerMesh.scale.set(0.2, 0.2, 1);
            markerMesh.position.copy(pos);
            worldRoot.add(markerMesh);
        }

        // --------------------------------------------------------------------------
        // 5. MAIN LOOP
        // --------------------------------------------------------------------------
        let frameCount = 0;

        function animate() {
            requestAnimationFrame(animate);
            frameCount++;
            
            if (controls) controls.update();
            
            if (isScanning) {
                updateGuideVisuals();
            }
            
            if (isTracking) {
                runVisualLocalization();
            }
            
            renderer.render(scene, camera);
        }

        function runVisualLocalization() {
            if (frameCount % 4 !== 0) return;

            const currentQ = camera.quaternion;
            const currentFP = extractVisualFingerprint(video);
            if(!currentFP) return;

            let bestDiff = 999;
            let bestIdx = -1;

            // Search captured library
            for (let i = 0; i < capturedPoints.length; i++) {
                if (currentQ.angleTo(capturedPoints[i].quaternion) < 0.3) {
                    const diff = compareFingerprints(currentFP, capturedPoints[i].visualData);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        bestIdx = i;
                    }
                }
            }

            if (bestIdx !== -1 && bestDiff < VISUAL_THRESHOLD) {
                lockIndicator.classList.add('locked');
                controls.correctDrift(capturedPoints[bestIdx].quaternion);

                // AUTO-RELOCATE MARKER
                if (markerMesh) {
                    raycaster.setFromCamera(centerScreen, camera);
                    const origin = raycaster.ray.origin;
                    const dir = raycaster.ray.direction;
                    
                    if (Math.abs(dir.y) > 0.05) {
                        const groundY = markerMesh.position.y;
                        const t = (groundY - origin.y) / dir.y;
                        if (t > 0) {
                            const visualHit = new THREE.Vector3().copy(origin).add(dir.multiplyScalar(t));
                            if (visualHit.distanceTo(markerMesh.position) < 0.8) {
                                markerMesh.position.lerp(visualHit, 0.05); // Smooth slide
                            }
                        }
                    }
                }
                debug.innerText = `LOCKED: Frame ${bestIdx} (Err: ${bestDiff.toFixed(1)})`;
            } else {
                lockIndicator.classList.remove('locked');
                debug.innerText = `Searching...`;
            }
        }

        // --------------------------------------------------------------------------
        // 6. INITIALIZATION
        // --------------------------------------------------------------------------
        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: false
                });
                video.srcObject = stream;
                video.play();
            } catch (e) { debug.innerText = "Cam Error: " + e.message; }
        }

        function initThree() {
            scene = new THREE.Scene();
            worldRoot = new THREE.Group();
            scene.add(worldRoot);

            camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 100);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            scene.add(new THREE.AmbientLight(0xffffff, 2));
            animate();
        }

        btnAction.addEventListener('click', () => {
            if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(r => { if(r==='granted') startScan(); });
            } else {
                startScan();
            }
        });

        btnFix.addEventListener('click', () => {
            if(markerMesh) markerMesh.position.set(0, -1, -2);
        });

        slider.addEventListener('input', (e) => {
            const s = parseFloat(e.target.value);
            if (markerMesh) markerMesh.scale.set(s,s,1);
        });

        function startScan() {
            controls = new OrientationManager(camera);
            controls.enabled = true;
            
            // Allow sensor to settle for 200ms before taking the "Zero" reading
            uiStatus.innerText = "Calibrating Sensors...";
            setTimeout(() => {
                startQuaternion.copy(camera.quaternion); // LOCK REFERENCE FRAME
                capturedPoints = [];
                scanTargets = generateScanTargets();
                currentTargetIndex = 0;
                isScanning = true;
                isTracking = false;
                btnAction.style.display = 'none';
            }, 200);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initCamera();
        initThree();

    </script>
</body>
</html>
